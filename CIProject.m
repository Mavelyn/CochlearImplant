clear
close all

filepath = 'C:\Users\mavel\Documents\BME 252\CI Project\.wav Files\';
%soundFiles = {dir(filepath).name};
%soundFiles = soundFiles(3:end);

soundFile = 'fo-4.wav';
%newSoundFile = 'Test1.wav';

% Read sound file and find sampling rate
filename = append(filepath, soundFile);
processSound(filepath, soundFile);

%audioData = processSound(filepath, soundFile);
%filteredSignal = butterBandpassFilter(audioData, 7800, 7999.99, 16000, 6);
%plot(filteredSignal);

%% Processes sound file and plots waveform
function processSound(filepath, soundFile)

filename = append(filepath, soundFile);

% Read sound file
[oldAudioData,sampleRate] = audioread(filename);

% Check whether input sound is stereo or mono
% Can also use audioinfo instead
[~, n] = size(oldAudioData);

% If stereo, add 2 columns to make 1 column
if n == 2
    audioData = sum(oldAudioData,2);
else
    audioData = oldAudioData;
end

% Update size
clear n;
[m, n] = size(audioData);

% Play sound (updated)
%sound(audioData,sampleRate);

% Create a new .wav file using y (audio data) and Fs (sample rate, Hz)
name = strsplit(soundFile, '.');
name = string(name(1));
newFilename = append(name,'-out','.wav');
audiowrite(newFilename, audioData, sampleRate);

% Plot sound waveform as a function of sample number
figure()
plot(audioData);
title('Sound Waveform');
xlabel('Sample Number');
ylabel('Amplitude');

% If sampling rate is not 16 kHz, downsample to 16 kHz
if sampleRate > 16000
    audioData = resample(audioData, 16000, sampleRate);
    sampleRate = 16000;
elseif sampleRate < 16000
    disp('Find new sound file with larger sample rate');
    return;
end

% Generate a signal using cosine function that oscillates at 1 kHz
% timeDuration = m/sampleRate;
% period = @(f) 1/f; % period function
% time = 0:period(sampleRate):timeDuration;
% freq = 1000; % Hz
% signal = @(t) cos(2*pi*freq*t);

% Play sound generated by signal
% pause(timeDuration);
% sound(signal(time),sampleRate);

% Plot two cycles of its waveform as a function of time
%figure()
%time2 = 0:period(sampleRate):2*period(freq);
%plot(time2, signal(time2));
%ylabel('Amplitude');
%xlabel('Time (s)');

% Set number of channels and channel spacing
N = 16;
spacing = 500;

outputSignal = 0;

for i = 1:N    
    % Set lower and upper corner frequency of bandpass filter
    if i == 1
        low = 100;
        high = 500;
    else
        low = 500 + (i-2)*spacing;
        high = low + spacing;
    end
    
    % BANDPASS FILTER
    filterOrder = 2;
    filteredSignal = butterBandpassFilter(audioData, low, high, sampleRate, filterOrder);
    centralFreq = (low + high) / 2;
    
    % ENVELOPE DETECTION
    % Rectify output signal
    rectifiedSignal = abs(filteredSignal);
    
    % Detect envelopes of rectified signals using a lowpass filter
    envelope = butterLowpassFilter(rectifiedSignal, 300, sampleRate, filterOrder);
    
    % Generate cosine signal with central frequency of bandpass
    % filters and length of rectified signal
    [r, ~] = size(rectifiedSignal);
    timeDuration = r/sampleRate;
    time = linspace(0, timeDuration, r);
    cosSignal = cos(2*pi*centralFreq*time);
    
    % AMPLITUDE MODULATION
    envelope = transpose(envelope);
    amSignal = envelope.*(cosSignal);
    
    % Sum amplitude modulated signals for each channel
    outputSignal = outputSignal + amSignal;
    
    % Plotting
    if i == 1
        figure()   
        plot(filteredSignal);
        title('Output Signal of Lowest Frequency Channel');
        xlabel('Sample Number');
        ylabel('Amplitude');
        
        figure()
        plot(envelope);
        title('Envelope of Lowest Frequency Channel');
        xlabel('Sample Number');
        
    elseif i == N
        figure()   
        plot(filteredSignal);
        title('Output Signal of Highest Frequency Channel');
        xlabel('Sample Number');
        ylabel('Amplitude');
        
        figure()
        plot(envelope);
        title('Envelope of Highest Frequency Channel');
        xlabel('Sample Number');
    end
        
end

% Normalize the signals by the max of their absolute value
outputSignalNorm = outputSignal / max(abs(outputSignal), [], 'all');
audioDataNorm = audioData / max(abs(audioData), [], 'all');

% Plot the normalized output signal
figure()
plot(outputSignalNorm);
title('Output Signal');
xlabel('Sample Number');
ylabel('Amplitude');

% Plot the normalized input signal
figure()
plot(time, audioDataNorm);
hold on;
plot(time, outputSignalNorm);
title('Original vs Processed Sound');
legend('Original', 'Processed');

% Play the output signal
sound(outputSignal, sampleRate);

end

function[y] = butterBandpassFilter(data, lowcut, highcut, sampleRate, order)
    % Nyquist frequency
    nyq = sampleRate/2;

    % Since the cutoff frequency cannot be equal to 1 and nyq = 8000,
    % the upper cutoff frequency must be less than 8000
    if highcut == nyq
        highcut = highcut - 0.00000000001;
    end
    
    % Normalize the frequencies by dividing by the Nyquist frequency
    low = lowcut/nyq;
    high = highcut/nyq;
    
    % butter() returns b,a which are transfer function coefficients
    [b, a] = butter(order, [low, high], 'bandpass');
    y = filter(b, a, data);
end

function[y] = butterLowpassFilter(data, cutoff, sampleRate, order)
    % Nyquist frequency 
    nyq = sampleRate/2;
    
    % Cutoff frequency cannot equal Nyquist frequency
    % so decrease slightly
    if cutoff == nyq
        cutoff = cuttoff - 0.00000000001;
    end
    
    % Normalize the cutoff frequency
    cutoffFreq = cutoff / nyq;
    
    [b, a] = butter(order, cutoffFreq, 'low');    
    y = filter(b, a, data);
end
